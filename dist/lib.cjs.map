{"version":3,"file":"lib.cjs","sources":["../src/utils/audio.ts","../src/utils/rawAudioProcessor.ts","../src/utils/input.ts","../src/utils/audioConcatProcessor.ts","../src/utils/output.ts","../src/utils/events.ts","../src/utils/connection.ts","../src/index.ts"],"sourcesContent":["export function arrayBufferToBase64(b: ArrayBufferLike) {\n  const buffer = new Uint8Array(b);\n  // @ts-ignore\n  const base64Data = window.btoa(String.fromCharCode(...buffer));\n  return base64Data;\n}\n\nexport function base64ToArrayBuffer(base64: string): ArrayBuffer {\n  const binaryString = window.atob(base64);\n  const len = binaryString.length;\n  const bytes = new Uint8Array(len);\n  for (let i = 0; i < len; i++) {\n    bytes[i] = binaryString.charCodeAt(i);\n  }\n  return bytes.buffer;\n}\n","/*\n * ulaw encoding logic taken from the wavefile library\n * https://github.com/rochars/wavefile/blob/master/lib/codecs/mulaw.js\n */\n\nconst blob = new Blob(\n  [\n    // language=JavaScript\n    `\n      const BIAS = 0x84;\n      const CLIP = 32635;\n      const encodeTable = [\n        0,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,\n        4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,\n        5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\n        5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\n        6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n        6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n        6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n        6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n        7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n        7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n        7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n        7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n        7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n        7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n        7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n        7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7\n      ];\n      \n      function encodeSample(sample) {\n        let sign;\n        let exponent;\n        let mantissa;\n        let muLawSample;\n        sign = (sample >> 8) & 0x80;\n        if (sign !== 0) sample = -sample;\n        sample = sample + BIAS;\n        if (sample > CLIP) sample = CLIP;\n        exponent = encodeTable[(sample>>7) & 0xFF];\n        mantissa = (sample >> (exponent+3)) & 0x0F;\n        muLawSample = ~(sign | (exponent << 4) | mantissa);\n        \n        return muLawSample;\n      }\n    \n      class RawAudioProcessor extends AudioWorkletProcessor {\n        constructor() {\n          super();\n                    \n          this.port.onmessage = ({ data }) => {\n            this.buffer = []; // Initialize an empty buffer\n            this.bufferSize = data.sampleRate / 4;\n            \n            if (globalThis.LibSampleRate && sampleRate !== data.sampleRate) {\n              globalThis.LibSampleRate.create(1, sampleRate, data.sampleRate).then(resampler => {\n                this.resampler = resampler;\n              });\n            } \n          };\n        }\n        process(inputs) {\n          if (!this.buffer) {\n            return true;\n          }\n          \n          const input = inputs[0]; // Get the first input node\n          if (input.length > 0) {\n            let channelData = input[0]; // Get the first channel's data\n\n            // Resample the audio if necessary\n            if (this.resampler) {\n              channelData = this.resampler.full(channelData);\n            }\n\n            // Add channel data to the buffer\n            this.buffer.push(...channelData);\n            // Get max volume \n            let sum = 0.0;\n            for (let i = 0; i < channelData.length; i++) {\n              sum += channelData[i] * channelData[i];\n            }\n            const maxVolume = Math.sqrt(sum / channelData.length);\n            // Check if buffer size has reached or exceeded the threshold\n            if (this.buffer.length >= this.bufferSize) {\n              const float32Array = new Float32Array(this.buffer)\n              let encodedArray = this.format === \"ulaw\"\n                ? new Uint8Array(float32Array.length)\n                : new Int16Array(float32Array.length);\n\n              // Iterate through the Float32Array and convert each sample to PCM16\n              for (let i = 0; i < float32Array.length; i++) {\n                // Clamp the value to the range [-1, 1]\n                let sample = Math.max(-1, Math.min(1, float32Array[i]));\n\n                // Scale the sample to the range [-32768, 32767]\n                let value = sample < 0 ? sample * 32768 : sample * 32767;\n                if (this.format === \"ulaw\") {\n                  value = encodeSample(Math.round(value));\n                }\n\n                encodedArray[i] = value;\n              }\n\n              // Send the buffered data to the main script\n              this.port.postMessage([encodedArray, maxVolume]);\n\n              // Clear the buffer after sending\n              this.buffer = [];\n            }\n          }\n          return true; // Continue processing\n        }\n      }\n      registerProcessor(\"raw-audio-processor\", RawAudioProcessor);\n  `,\n  ],\n  { type: \"application/javascript\" }\n);\n\nexport const rawAudioProcessor = URL.createObjectURL(blob);\n","import { rawAudioProcessor } from \"./rawAudioProcessor\";\nimport { FormatConfig } from \"./connection\";\n\nexport type InputConfig = {\n  preferHeadphonesForIosDevices?: boolean;\n};\n\nconst LIBSAMPLERATE_JS =\n  \"https://cdn.jsdelivr.net/npm/@alexanderolsen/libsamplerate-js@2.1.2/dist/libsamplerate.worklet.js\";\n\nfunction isIosDevice() {\n  return (\n    [\n      \"iPad Simulator\",\n      \"iPhone Simulator\",\n      \"iPod Simulator\",\n      \"iPad\",\n      \"iPhone\",\n      \"iPod\",\n    ].includes(navigator.platform) ||\n    // iPad on iOS 13 detection\n    (navigator.userAgent.includes(\"Mac\") && \"ontouchend\" in document)\n  );\n}\n\nexport class Input {\n  public static async create({\n    sampleRate,\n    format,\n    preferHeadphonesForIosDevices,\n  }: FormatConfig & InputConfig): Promise<Input> {\n    let context: AudioContext | null = null;\n    let inputStream: MediaStream | null = null;\n\n    try {\n      const options: MediaTrackConstraints = {\n        sampleRate: { ideal: sampleRate },\n        echoCancellation: { ideal: true },\n        noiseSuppression: { ideal: true },\n      };\n\n      // some browsers won't allow calling getSupportedConstraints or enumerateDevices\n      // before getting approval for microphone access\n      const preliminaryInputStream = await navigator.mediaDevices.getUserMedia({\n        audio: true,\n      });\n      preliminaryInputStream?.getTracks().forEach(track => track.stop());\n\n      if (isIosDevice() && preferHeadphonesForIosDevices) {\n        const availableDevices =\n          await window.navigator.mediaDevices.enumerateDevices();\n        const idealDevice = availableDevices.find(\n          d =>\n            // cautious to include \"bluetooth\" in the search\n            // as might trigger bluetooth speakers\n            d.kind === \"audioinput\" &&\n            [\"airpod\", \"headphone\", \"earphone\"].find(keyword =>\n              d.label.toLowerCase().includes(keyword)\n            )\n        );\n        if (idealDevice) {\n          options.deviceId = { ideal: idealDevice.deviceId };\n        }\n      }\n\n      const supportsSampleRateConstraint =\n        navigator.mediaDevices.getSupportedConstraints().sampleRate;\n\n      context = new window.AudioContext(\n        supportsSampleRateConstraint ? { sampleRate } : {}\n      );\n      const analyser = context.createAnalyser();\n      if (!supportsSampleRateConstraint) {\n        await context.audioWorklet.addModule(LIBSAMPLERATE_JS);\n      }\n      await context.audioWorklet.addModule(rawAudioProcessor);\n\n      inputStream = await navigator.mediaDevices.getUserMedia({\n        audio: options,\n      });\n\n      const source = context.createMediaStreamSource(inputStream);\n      const worklet = new AudioWorkletNode(context, \"raw-audio-processor\");\n      worklet.port.postMessage({ type: \"setFormat\", format, sampleRate });\n\n      source.connect(analyser);\n      analyser.connect(worklet);\n\n      return new Input(context, analyser, worklet, inputStream);\n    } catch (error) {\n      inputStream?.getTracks().forEach(track => track.stop());\n      context?.close();\n      throw error;\n    }\n  }\n\n  private constructor(\n    public readonly context: AudioContext,\n    public readonly analyser: AnalyserNode,\n    public readonly worklet: AudioWorkletNode,\n    public readonly inputStream: MediaStream\n  ) {}\n\n  public async close() {\n    this.inputStream.getTracks().forEach(track => track.stop());\n    await this.context.close();\n  }\n}\n","/*\n * ulaw decoding logic taken from the wavefile library\n * https://github.com/rochars/wavefile/blob/master/lib/codecs/mulaw.js\n */\n\nconst blob = new Blob(\n  [\n    // language=JavaScript\n    `\n      const decodeTable = [0,132,396,924,1980,4092,8316,16764];\n      \n      export function decodeSample(muLawSample) {\n        let sign;\n        let exponent;\n        let mantissa;\n        let sample;\n        muLawSample = ~muLawSample;\n        sign = (muLawSample & 0x80);\n        exponent = (muLawSample >> 4) & 0x07;\n        mantissa = muLawSample & 0x0F;\n        sample = decodeTable[exponent] + (mantissa << (exponent+3));\n        if (sign !== 0) sample = -sample;\n\n        return sample;\n      }\n      \n      class AudioConcatProcessor extends AudioWorkletProcessor {\n        constructor() {\n          super();\n          this.buffers = []; // Initialize an empty buffer\n          this.cursor = 0;\n          this.currentBuffer = null;\n          this.wasInterrupted = false;\n          this.finished = false;\n          \n          this.port.onmessage = ({ data }) => {\n            switch (data.type) {\n              case \"setFormat\":\n                this.format = data.format;\n                break;\n              case \"buffer\":\n                this.wasInterrupted = false;\n                this.buffers.push(\n                  this.format === \"ulaw\"\n                    ? new Uint8Array(data.buffer)\n                    : new Int16Array(data.buffer)\n                );\n                break;\n              case \"interrupt\":\n                this.wasInterrupted = true;\n                break;\n              case \"clearInterrupted\":\n                if (this.wasInterrupted) {\n                  this.wasInterrupted = false;\n                  this.buffers = [];\n                  this.currentBuffer = null;\n                }\n            }\n          };\n        }\n        process(_, outputs) {\n          let finished = false;\n          const output = outputs[0][0];\n          for (let i = 0; i < output.length; i++) {\n            if (!this.currentBuffer) {\n              if (this.buffers.length === 0) {\n                finished = true;\n                break;\n              }\n              this.currentBuffer = this.buffers.shift();\n              this.cursor = 0;\n            }\n\n            let value = this.currentBuffer[this.cursor];\n            if (this.format === \"ulaw\") {\n              value = decodeSample(value);\n            }\n            output[i] = value / 32768;\n            this.cursor++;\n\n            if (this.cursor >= this.currentBuffer.length) {\n              this.currentBuffer = null;\n            }\n          }\n\n          if (this.finished !== finished) {\n            this.finished = finished;\n            this.port.postMessage({ type: \"process\", finished });\n          }\n\n          return true; // Continue processing\n        }\n      }\n\n      registerProcessor(\"audio-concat-processor\", AudioConcatProcessor);\n    `,\n  ],\n  { type: \"application/javascript\" }\n);\n\nexport const audioConcatProcessor = URL.createObjectURL(blob);\n","import { audioConcatProcessor } from \"./audioConcatProcessor\";\nimport { FormatConfig } from \"./connection\";\n\nexport class Output {\n  public static async create({\n    sampleRate,\n    format,\n  }: FormatConfig): Promise<Output> {\n    let context: AudioContext | null = null;\n    try {\n      context = new AudioContext({ sampleRate });\n      const analyser = context.createAnalyser();\n      const gain = context.createGain();\n      gain.connect(analyser);\n      analyser.connect(context.destination);\n      await context.audioWorklet.addModule(audioConcatProcessor);\n      const worklet = new AudioWorkletNode(context, \"audio-concat-processor\");\n      worklet.port.postMessage({ type: \"setFormat\", format });\n      worklet.connect(gain);\n\n      return new Output(context, analyser, gain, worklet);\n    } catch (error) {\n      context?.close();\n      throw error;\n    }\n  }\n\n  private constructor(\n    public readonly context: AudioContext,\n    public readonly analyser: AnalyserNode,\n    public readonly gain: GainNode,\n    public readonly worklet: AudioWorkletNode\n  ) {}\n\n  public async close() {\n    await this.context.close();\n  }\n}\n","import { Language } from \"./connection\";\n\nexport type UserTranscriptionEvent = {\n  type: \"user_transcript\";\n  user_transcription_event: { user_transcript: string };\n};\nexport type AgentResponseEvent = {\n  type: \"agent_response\";\n  agent_response_event: { agent_response: string };\n};\nexport type AgentAudioEvent = {\n  type: \"audio\";\n  audio_event: {\n    audio_base_64: string;\n    event_id: number;\n  };\n};\nexport type InterruptionEvent = {\n  type: \"interruption\";\n  interruption_event: {\n    event_id: number;\n  };\n};\nexport type InternalTentativeAgentResponseEvent = {\n  type: \"internal_tentative_agent_response\";\n  tentative_agent_response_internal_event: {\n    tentative_agent_response: string;\n  };\n};\nexport type ConfigEvent = {\n  type: \"conversation_initiation_metadata\";\n  conversation_initiation_metadata_event: {\n    conversation_id: string;\n    agent_output_audio_format: string;\n    user_input_audio_format?: string;\n  };\n};\nexport type PingEvent = {\n  type: \"ping\";\n  ping_event: {\n    event_id: number;\n    ping_ms?: number;\n  };\n};\nexport type ClientToolCallEvent = {\n  type: \"client_tool_call\";\n  client_tool_call: {\n    tool_name: string;\n    tool_call_id: string;\n    parameters: any;\n    expects_response: boolean;\n  };\n};\n\n// TODO correction missing\nexport type IncomingSocketEvent =\n  | UserTranscriptionEvent\n  | AgentResponseEvent\n  | AgentAudioEvent\n  | InterruptionEvent\n  | InternalTentativeAgentResponseEvent\n  | ConfigEvent\n  | PingEvent\n  | ClientToolCallEvent;\n\nexport type PongEvent = {\n  type: \"pong\";\n  event_id: number;\n};\nexport type UserAudioEvent = {\n  user_audio_chunk: string;\n};\nexport type UserFeedbackEvent = {\n  type: \"feedback\";\n  score: \"like\" | \"dislike\";\n  event_id: number;\n};\nexport type ClientToolResultEvent = {\n  type: \"client_tool_result\";\n  tool_call_id: string;\n  result: any;\n  is_error: boolean;\n};\nexport type InitiationClientDataEvent = {\n  type: \"conversation_initiation_client_data\";\n  conversation_config_override?: {\n    agent?: {\n      prompt?: {\n        prompt?: string;\n      };\n      first_message?: string;\n      language?: Language;\n    };\n    tts?: {\n      voice_id?: string;\n    };\n  };\n  custom_llm_extra_body?: any;\n};\nexport type OutgoingSocketEvent =\n  | PongEvent\n  | UserAudioEvent\n  | InitiationClientDataEvent\n  | UserFeedbackEvent\n  | ClientToolResultEvent;\n\nexport function isValidSocketEvent(event: any): event is IncomingSocketEvent {\n  return !!event.type;\n}\n","import {\n  InitiationClientDataEvent,\n  ConfigEvent,\n  isValidSocketEvent,\n  OutgoingSocketEvent,\n} from \"./events\";\n\nconst MAIN_PROTOCOL = \"convai\";\n\nexport type Language =\n  | \"en\"\n  | \"ja\"\n  | \"zh\"\n  | \"de\"\n  | \"hi\"\n  | \"fr\"\n  | \"ko\"\n  | \"pt\"\n  | \"it\"\n  | \"es\"\n  | \"id\"\n  | \"nl\"\n  | \"tr\"\n  | \"pl\"\n  | \"sv\"\n  | \"bg\"\n  | \"ro\"\n  | \"ar\"\n  | \"cs\"\n  | \"el\"\n  | \"fi\"\n  | \"ms\"\n  | \"da\"\n  | \"ta\"\n  | \"uk\"\n  | \"ru\"\n  | \"hu\"\n  | \"no\"\n  | \"vi\";\nexport type SessionConfig = {\n  origin?: string;\n  authorization?: string;\n  overrides?: {\n    agent?: {\n      prompt?: {\n        prompt?: string;\n      };\n      firstMessage?: string;\n      language?: Language;\n    };\n    tts?: {\n      voiceId?: string;\n    };\n  };\n  customLlmExtraBody?: any;\n} & (\n  | { signedUrl: string; agentId?: undefined }\n  | { agentId: string; signedUrl?: undefined }\n);\nexport type FormatConfig = {\n  format: \"pcm\" | \"ulaw\";\n  sampleRate: number;\n};\n\nconst WSS_API_ORIGIN = \"wss://api.elevenlabs.io\";\nconst WSS_API_PATHNAME = \"/v1/convai/conversation?agent_id=\";\n\nexport class Connection {\n  public static async create(config: SessionConfig): Promise<Connection> {\n    let socket: WebSocket | null = null;\n\n    try {\n      const origin = config.origin ?? WSS_API_ORIGIN;\n      const url = config.signedUrl\n        ? config.signedUrl\n        : origin + WSS_API_PATHNAME + config.agentId;\n\n      const protocols = [MAIN_PROTOCOL];\n      if (config.authorization) {\n        protocols.push(`bearer.${config.authorization}`);\n      }\n      socket = new WebSocket(url, protocols);\n      const conversationConfig = await new Promise<\n        ConfigEvent[\"conversation_initiation_metadata_event\"]\n      >((resolve, reject) => {\n        socket!.addEventListener(\n          \"open\",\n          () => {\n            const overridesEvent: InitiationClientDataEvent = {\n              type: \"conversation_initiation_client_data\",\n            };\n\n            if (config.overrides) {\n              overridesEvent.conversation_config_override = {\n                agent: {\n                  prompt: config.overrides.agent?.prompt,\n                  first_message: config.overrides.agent?.firstMessage,\n                  language: config.overrides.agent?.language,\n                },\n                tts: {\n                  voice_id: config.overrides.tts?.voiceId,\n                },\n              };\n            }\n\n            if (config.customLlmExtraBody) {\n              overridesEvent.custom_llm_extra_body = config.customLlmExtraBody;\n            }\n\n            socket?.send(JSON.stringify(overridesEvent));\n          },\n          { once: true }\n        );\n        socket!.addEventListener(\"error\", reject);\n        socket!.addEventListener(\"close\", reject);\n        socket!.addEventListener(\n          \"message\",\n          (event: MessageEvent) => {\n            const message = JSON.parse(event.data);\n\n            if (!isValidSocketEvent(message)) {\n              return;\n            }\n\n            if (message.type === \"conversation_initiation_metadata\") {\n              resolve(message.conversation_initiation_metadata_event);\n            } else {\n              console.warn(\n                \"First received message is not conversation metadata.\"\n              );\n            }\n          },\n          { once: true }\n        );\n      });\n\n      const {\n        conversation_id,\n        agent_output_audio_format,\n        user_input_audio_format,\n      } = conversationConfig;\n\n      const inputFormat = parseFormat(user_input_audio_format ?? \"pcm_16000\");\n      const outputFormat = parseFormat(agent_output_audio_format);\n\n      return new Connection(socket, conversation_id, inputFormat, outputFormat);\n    } catch (error) {\n      socket?.close();\n      throw error;\n    }\n  }\n\n  private constructor(\n    public readonly socket: WebSocket,\n    public readonly conversationId: string,\n    public readonly inputFormat: FormatConfig,\n    public readonly outputFormat: FormatConfig\n  ) {}\n\n  public close() {\n    this.socket.close();\n  }\n\n  public sendMessage(message: OutgoingSocketEvent) {\n    this.socket.send(JSON.stringify(message));\n  }\n}\n\nfunction parseFormat(format: string): FormatConfig {\n  const [formatPart, sampleRatePart] = format.split(\"_\");\n  if (![\"pcm\", \"ulaw\"].includes(formatPart)) {\n    throw new Error(`Invalid format: ${format}`);\n  }\n\n  const sampleRate = parseInt(sampleRatePart);\n  if (isNaN(sampleRate)) {\n    throw new Error(`Invalid sample rate: ${sampleRatePart}`);\n  }\n\n  return {\n    format: formatPart as FormatConfig[\"format\"],\n    sampleRate,\n  };\n}\n","import { arrayBufferToBase64, base64ToArrayBuffer } from \"./utils/audio\";\nimport { Input, InputConfig } from \"./utils/input\";\nimport { Output } from \"./utils/output\";\nimport { Connection, SessionConfig } from \"./utils/connection\";\nimport {\n  ClientToolCallEvent,\n  isValidSocketEvent,\n  PingEvent,\n} from \"./utils/events\";\n\nexport type { IncomingSocketEvent } from \"./utils/events\";\nexport type { SessionConfig } from \"./utils/connection\";\n\nexport type Role = \"user\" | \"ai\";\nexport type Mode = \"speaking\" | \"listening\";\nexport type Status =\n  | \"connecting\"\n  | \"connected\"\n  | \"disconnecting\"\n  | \"disconnected\";\nexport type Options = SessionConfig &\n  Callbacks &\n  ClientToolsConfig &\n  InputConfig;\nexport type ClientToolsConfig = {\n  clientTools: Record<\n    string,\n    (\n      parameters: any\n    ) => Promise<string | number | void> | string | number | void\n  >;\n};\nexport type Callbacks = {\n  onConnect: (props: { conversationId: string }) => void;\n  // internal debug events, not to be used\n  onDebug: (props: any) => void;\n  onDisconnect: () => void;\n  onError: (message: string, context?: any) => void;\n  onMessage: (props: { message: string; source: Role }) => void;\n  onModeChange: (prop: { mode: Mode }) => void;\n  onStatusChange: (prop: { status: Status }) => void;\n  onCanSendFeedbackChange: (prop: { canSendFeedback: boolean }) => void;\n  onUnhandledClientToolCall?: (\n    params: ClientToolCallEvent[\"client_tool_call\"]\n  ) => void;\n};\n\nconst defaultClientTools = { clientTools: {} };\nconst defaultCallbacks: Callbacks = {\n  onConnect: () => {},\n  onDebug: () => {},\n  onDisconnect: () => {},\n  onError: () => {},\n  onMessage: () => {},\n  onModeChange: () => {},\n  onStatusChange: () => {},\n  onCanSendFeedbackChange: () => {},\n};\n\nconst HTTPS_API_ORIGIN = \"https://api.elevenlabs.io\";\n\nexport class Conversation {\n  public static async startSession(\n    options: SessionConfig &\n      Partial<Callbacks> &\n      Partial<ClientToolsConfig> &\n      Partial<InputConfig>\n  ): Promise<Conversation> {\n    const fullOptions: Options = {\n      ...defaultClientTools,\n      ...defaultCallbacks,\n      ...options,\n    };\n\n    fullOptions.onStatusChange({ status: \"connecting\" });\n    fullOptions.onCanSendFeedbackChange({ canSendFeedback: false });\n\n    let input: Input | null = null;\n    let connection: Connection | null = null;\n    let output: Output | null = null;\n\n    try {\n      connection = await Connection.create(options);\n      [input, output] = await Promise.all([\n        Input.create({\n          ...connection.inputFormat,\n          preferHeadphonesForIosDevices: options.preferHeadphonesForIosDevices,\n        }),\n        Output.create(connection.outputFormat),\n      ]);\n\n      return new Conversation(fullOptions, connection, input, output);\n    } catch (error) {\n      fullOptions.onStatusChange({ status: \"disconnected\" });\n      connection?.close();\n      await input?.close();\n      await output?.close();\n      throw error;\n    }\n  }\n\n  private lastInterruptTimestamp: number = 0;\n  private mode: Mode = \"listening\";\n  private status: Status = \"connecting\";\n  private inputFrequencyData?: Uint8Array;\n  private outputFrequencyData?: Uint8Array;\n  private volume: number = 1;\n  private currentEventId: number = 1;\n  private lastFeedbackEventId: number = 1;\n  private canSendFeedback: boolean = false;\n\n  private constructor(\n    private readonly options: Options,\n    private readonly connection: Connection,\n    public readonly input: Input,\n    public readonly output: Output\n  ) {\n    this.options.onConnect({ conversationId: connection.conversationId });\n\n    this.connection.socket.addEventListener(\"message\", (event) => {\n      this.onEvent(event);\n    });\n    this.connection.socket.addEventListener(\"error\", (event) => {\n      this.updateStatus(\"disconnected\");\n      this.onError(\"Socket error\", event);\n    });\n    this.connection.socket.addEventListener(\"close\", () => {\n      this.updateStatus(\"disconnected\");\n      this.options.onDisconnect();\n    });\n\n    this.input.worklet.port.onmessage = this.onInputWorkletMessage;\n    this.output.worklet.port.onmessage = this.onOutputWorkletMessage;\n    this.updateStatus(\"connected\");\n  }\n\n  public endSession = async () => {\n    if (this.status !== \"connected\") return;\n    this.updateStatus(\"disconnecting\");\n\n    this.connection.close();\n    await this.input.close();\n    await this.output.close();\n\n    this.updateStatus(\"disconnected\");\n  };\n\n  private updateMode = (mode: Mode) => {\n    if (mode !== this.mode) {\n      this.mode = mode;\n      this.options.onModeChange({ mode });\n    }\n  };\n\n  private updateStatus = (status: Status) => {\n    if (status !== this.status) {\n      this.status = status;\n      this.options.onStatusChange({ status });\n    }\n  };\n\n  private updateCanSendFeedback = () => {\n    const canSendFeedback = this.currentEventId !== this.lastFeedbackEventId;\n    if (this.canSendFeedback !== canSendFeedback) {\n      this.canSendFeedback = canSendFeedback;\n      this.options.onCanSendFeedbackChange({ canSendFeedback });\n    }\n  };\n\n  private onEvent = async (event: MessageEvent) => {\n    try {\n      const parsedEvent = JSON.parse(event.data);\n\n      if (!isValidSocketEvent(parsedEvent)) {\n        return;\n      }\n\n      switch (parsedEvent.type) {\n        case \"interruption\": {\n          if (parsedEvent.interruption_event) {\n            this.lastInterruptTimestamp =\n              parsedEvent.interruption_event.event_id;\n          }\n          this.fadeOutAudio();\n          break;\n        }\n\n        case \"agent_response\": {\n          this.options.onMessage({\n            source: \"ai\",\n            message: parsedEvent.agent_response_event.agent_response,\n          });\n          break;\n        }\n\n        case \"user_transcript\": {\n          this.options.onMessage({\n            source: \"user\",\n            message: parsedEvent.user_transcription_event.user_transcript,\n          });\n          break;\n        }\n\n        case \"internal_tentative_agent_response\": {\n          this.options.onDebug({\n            type: \"tentative_agent_response\",\n            response:\n              parsedEvent.tentative_agent_response_internal_event\n                .tentative_agent_response,\n          });\n          break;\n        }\n\n        case \"client_tool_call\": {\n          if (\n            this.options.clientTools.hasOwnProperty(\n              parsedEvent.client_tool_call.tool_name\n            )\n          ) {\n            try {\n              const result =\n                (await this.options.clientTools[\n                  parsedEvent.client_tool_call.tool_name\n                ](parsedEvent.client_tool_call.parameters)) ??\n                \"Client tool execution successful.\"; // default client-tool call response\n\n              this.connection.sendMessage({\n                type: \"client_tool_result\",\n                tool_call_id: parsedEvent.client_tool_call.tool_call_id,\n                result: result,\n                is_error: false,\n              });\n            } catch (e) {\n              this.onError(\n                \"Client tool execution failed with following error: \" +\n                  (e as Error)?.message,\n                {\n                  clientToolName: parsedEvent.client_tool_call.tool_name,\n                }\n              );\n              this.connection.sendMessage({\n                type: \"client_tool_result\",\n                tool_call_id: parsedEvent.client_tool_call.tool_call_id,\n                result:\n                  \"Client tool execution failed: \" + (e as Error)?.message,\n                is_error: true,\n              });\n            }\n\n            break;\n          }\n\n          if (this.options.onUnhandledClientToolCall) {\n            this.options.onUnhandledClientToolCall(\n              parsedEvent.client_tool_call\n            );\n\n            break;\n          }\n\n          this.onError(\n            `Client tool with name ${parsedEvent.client_tool_call.tool_name} is not defined on client`,\n            {\n              clientToolName: parsedEvent.client_tool_call.tool_name,\n            }\n          );\n          this.connection.sendMessage({\n            type: \"client_tool_result\",\n            tool_call_id: parsedEvent.client_tool_call.tool_call_id,\n            result: `Client tool with name ${parsedEvent.client_tool_call.tool_name} is not defined on client`,\n            is_error: true,\n          });\n\n          break;\n        }\n\n        case \"audio\": {\n          if (this.lastInterruptTimestamp <= parsedEvent.audio_event.event_id) {\n            this.addAudioBase64Chunk(parsedEvent.audio_event.audio_base_64);\n            this.currentEventId = parsedEvent.audio_event.event_id;\n            this.updateCanSendFeedback();\n            this.updateMode(\"speaking\");\n          }\n          break;\n        }\n\n        case \"ping\": {\n          this.connection.sendMessage({\n            type: \"pong\",\n            event_id: (parsedEvent as PingEvent).ping_event.event_id,\n          });\n          // parsedEvent.ping_event.ping_ms can be used on client side, for example\n          // to warn if ping is too high that experience might be degraded.\n          break;\n        }\n\n        // unhandled events are expected to be internal events\n        default: {\n          this.options.onDebug(parsedEvent);\n          break;\n        }\n      }\n    } catch {\n      this.onError(\"Failed to parse event data\", { event });\n      return;\n    }\n  };\n\n  private onInputWorkletMessage = (event: MessageEvent): void => {\n    const rawAudioPcmData = event.data[0];\n    const maxVolume = event.data[1];\n\n    // check if the sound was loud enough, so we don't send unnecessary chunks\n    // then forward audio to websocket\n    //if (maxVolume > 0.001) {\n    if (this.status === \"connected\") {\n      this.connection.sendMessage({\n        user_audio_chunk: arrayBufferToBase64(rawAudioPcmData.buffer),\n        //sample_rate: this.inputAudioContext?.inputSampleRate || this.inputSampleRate,\n      });\n    }\n    //}\n  };\n\n  private onOutputWorkletMessage = ({ data }: MessageEvent): void => {\n    if (data.type === \"process\") {\n      this.updateMode(data.finished ? \"listening\" : \"speaking\");\n    }\n  };\n\n  private addAudioBase64Chunk = async (chunk: string) => {\n    this.output.gain.gain.value = this.volume;\n    this.output.worklet.port.postMessage({ type: \"clearInterrupted\" });\n    this.output.worklet.port.postMessage({\n      type: \"buffer\",\n      buffer: base64ToArrayBuffer(chunk),\n    });\n  };\n\n  private fadeOutAudio = async () => {\n    // mute agent\n    this.updateMode(\"listening\");\n    this.output.worklet.port.postMessage({ type: \"interrupt\" });\n    this.output.gain.gain.exponentialRampToValueAtTime(\n      0.0001,\n      this.output.context.currentTime + 2\n    );\n\n    // reset volume back\n    setTimeout(() => {\n      this.output.gain.gain.value = this.volume;\n      this.output.worklet.port.postMessage({ type: \"clearInterrupted\" });\n    }, 2000); // Adjust the duration as needed\n  };\n\n  private onError = (message: string, context?: any) => {\n    console.error(message, context);\n    this.options.onError(message, context);\n  };\n\n  private calculateVolume = (frequencyData: Uint8Array) => {\n    if (frequencyData.length === 0) {\n      return 0;\n    }\n\n    // TODO: Currently this averages all frequencies, but we should probably\n    // bias towards the frequencies that are more typical for human voice\n    let volume = 0;\n    for (let i = 0; i < frequencyData.length; i++) {\n      volume += frequencyData[i] / 255;\n    }\n    volume /= frequencyData.length;\n\n    return volume < 0 ? 0 : volume > 1 ? 1 : volume;\n  };\n\n  public getId = () => this.connection.conversationId;\n\n  public setVolume = ({ volume }: { volume: number }) => {\n    this.volume = volume;\n  };\n\n  public getInputByteFrequencyData = () => {\n    this.inputFrequencyData ??= new Uint8Array(\n      this.input.analyser.frequencyBinCount\n    );\n    this.input.analyser.getByteFrequencyData(this.inputFrequencyData);\n    return this.inputFrequencyData;\n  };\n\n  public getOutputByteFrequencyData = () => {\n    this.outputFrequencyData ??= new Uint8Array(\n      this.output.analyser.frequencyBinCount\n    );\n    this.output.analyser.getByteFrequencyData(this.outputFrequencyData);\n    return this.outputFrequencyData;\n  };\n\n  public getInputVolume = () => {\n    return this.calculateVolume(this.getInputByteFrequencyData());\n  };\n\n  public getOutputVolume = () => {\n    return this.calculateVolume(this.getOutputByteFrequencyData());\n  };\n\n  public sendFeedback = (like: boolean) => {\n    if (!this.canSendFeedback) {\n      console.warn(\n        this.lastFeedbackEventId === 0\n          ? \"Cannot send feedback: the conversation has not started yet.\"\n          : \"Cannot send feedback: feedback has already been sent for the current response.\"\n      );\n      return;\n    }\n\n    this.connection.sendMessage({\n      type: \"feedback\",\n      score: like ? \"like\" : \"dislike\",\n      event_id: this.currentEventId,\n    });\n    this.lastFeedbackEventId = this.currentEventId;\n    this.updateCanSendFeedback();\n  };\n}\n\nexport function postOverallFeedback(\n  conversationId: string,\n  like: boolean,\n  origin: string = HTTPS_API_ORIGIN\n) {\n  return fetch(`${origin}/v1/convai/conversations/${conversationId}/feedback`, {\n    method: \"POST\",\n    body: JSON.stringify({\n      feedback: like ? \"like\" : \"dislike\",\n    }),\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n  });\n}\n"],"names":["base64ToArrayBuffer","base64","binaryString","window","atob","len","length","bytes","Uint8Array","i","charCodeAt","buffer","blob","Blob","type","rawAudioProcessor","URL","createObjectURL","Input","context","analyser","worklet","inputStream","this","create","_ref","sampleRate","format","preferHeadphonesForIosDevices","Promise","resolve","options","ideal","echoCancellation","noiseSuppression","navigator","mediaDevices","getUserMedia","audio","then","preliminaryInputStream","_temp4","_temp2","audioWorklet","addModule","_navigator$mediaDevic","source","createMediaStreamSource","AudioWorkletNode","port","postMessage","connect","supportsSampleRateConstraint","getSupportedConstraints","AudioContext","createAnalyser","_temp","getTracks","forEach","track","stop","_temp3","includes","platform","userAgent","document","enumerateDevices","availableDevices","idealDevice","find","d","kind","keyword","label","toLowerCase","deviceId","_catch","error","_inputStream","_context","close","e","reject","prototype","audioConcatProcessor","Output","gain","createGain","destination","isValidSocketEvent","event","Connection","socket","conversationId","inputFormat","outputFormat","config","origin","_config$origin","url","signedUrl","agentId","protocols","authorization","push","WebSocket","addEventListener","_socket","_config$overrides$age","_config$overrides$age2","_config$overrides$age3","_config$overrides$tts","overridesEvent","overrides","conversation_config_override","agent","prompt","first_message","firstMessage","language","tts","voice_id","voiceId","customLlmExtraBody","custom_llm_extra_body","send","JSON","stringify","once","message","parse","data","conversation_initiation_metadata_event","console","warn","conversationConfig","conversation_id","agent_output_audio_format","user_input_audio_format","parseFormat","_socket2","_proto","sendMessage","_format$split","split","formatPart","sampleRatePart","Error","parseInt","isNaN","defaultClientTools","clientTools","pact","state","value","s","_Pact","o","_settle","bind","v","observer","defaultCallbacks","onConnect","onDebug","onDisconnect","onError","onMessage","onModeChange","onStatusChange","onCanSendFeedbackChange","result","callback","onFulfilled","onRejected","_this","Conversation","connection","input","output","_this2","_this3","_this4","_this5","lastInterruptTimestamp","mode","status","inputFrequencyData","outputFrequencyData","volume","currentEventId","lastFeedbackEventId","canSendFeedback","endSession","updateStatus","updateMode","updateCanSendFeedback","onEvent","_interrupt","parsedEvent","_temp5","_switch","interruption_event","event_id","fadeOutAudio","agent_response_event","agent_response","user_transcription_event","user_transcript","response","tentative_agent_response_internal_event","tentative_agent_response","onUnhandledClientToolCall","client_tool_call","tool_name","clientToolName","tool_call_id","is_error","hasOwnProperty","parameters","audio_event","addAudioBase64Chunk","audio_base_64","ping_event","onInputWorkletMessage","b","user_audio_chunk","btoa","String","fromCharCode","apply","onOutputWorkletMessage","finished","chunk","exponentialRampToValueAtTime","currentTime","setTimeout","calculateVolume","frequencyData","getId","setVolume","_ref2","getInputByteFrequencyData","frequencyBinCount","getByteFrequencyData","getOutputByteFrequencyData","_this2$outputFrequenc","getInputVolume","getOutputVolume","sendFeedback","like","score","onmessage","startSession","fullOptions","_extends","_Connection$create","all","_Promise$all","_connection","_input","_output","fetch","method","body","feedback","headers"],"mappings":"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"}